<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>spritesheet text</title>
  </head>

  <body onload="main()">
    <canvas id="webgl" width="512" height="512" style="border:1px solid #000000;">
    Please use a browser that supports "canvas"
    </canvas>
	<!--canvas id="canvas2" height=512" width="512" style="border:1px solid #000000; background:transparent; visibility:visible;">
	</canvas-->
	<div id="fps">fps info here</div>

<script>
// Information for using WordHolder class
/*
API: 
	1) User activities WordHolder() constructor
	2) User adds as many words as needed with AddWord()
			AddWord(text, x, y, font);
	3) At any time between adding words, user can change font
		obj.setFont(font);
	4) At any time between adding words, user can check current font
		obj.getFont(font);
	5) Renderer automatically draws contents each cycle

Use case 1: New canvas needed
1) User calls addWord()
2) addWord calls tryAdd() on last canvas in array
2) last canvas in array tests the word
3) The word is too wide for the current line and too tall for next line
4) tryAdd() returns false
5) addWord calls addCanvas
6) new canvas with same font is added to array in WordHolder
	nextY automatically set to height of old font
7) tryAdd() called again
8) tryAdd() returns true as is blank canvas
8.5) if tryAdd fails now, could mean word is too big for entire canvas
9) Now Word constructor called and new word added to array of words

Use case 2: Font change needed
1) User calls setFont in WordHolder
2) setFont calls changeFont in latest SmartCanvas
3) Font is changed in smart canvas
4) changeFont calls getFontHeight()
5) NextY updated accordingly. The current line gets taller or stays the same
6) ready to write in new font

Use case 3: rendering words
1) Renderer cycles through each Word in array of Words
2) Use vertices to get info for vertex buffers
3) use canvas.texture to find correct texture for each word

*/ 
//

// Global object that holds words and has the canvas array
// WordHolder contains array of Word Objects
// WordHolder contains array of SmartCanvas Objects
function WordHolder(){
	// Default size of canvas
	this.defaultSize = 512; // here for easy access

	// 1D array [word, word, word, ...]
	this.wordArray = [];

	// array [canvas, canvas, canvas, ...]
	this.canvasArray = [];
	
	// Start with 1 empty smartcanvas
	this.canvasArray.push(new SmartCanvas('24px "Times New Roman"',this.defaultSize));	
}
// addWord(): User uses this function to add words
WordHolder.prototype.addWord = function(text,x,y){
	var testval = this.tryAdd(text);
	var latest = this.canvasArray[this.canvasArray.length-1];
	var widthHeight;
	
	// Add to canvas according to testval
	if(testval !== -1){ // no need for new canvas
		widthHeight = latest.writeWord(text, testval);
	}
	else{ // need new canvas
		this.addCanvas();
		latest = this.canvasArray[this.canvasArray.length-1];
		widthHeight = latest.writeWord(text, 0);
	}
	
	// Add word to wordArray
	//Word(text, canvas, x, y, xc, yc, widthc, heightc)
	// widthHeight[0],widthHeight[1],newcanvas.lastX,newcanvas.nextY
	this.wordArray.push(new Word(text, latest, x, y, widthHeight[0], widthHeight[1], latest.lastX-widthHeight[0], latest.nextY));
}
// tryAdd(): Adds a word to current canvas
//			if canvas is full, adds another canvas
//			is called by AddWord
WordHolder.prototype.tryAdd = function(text){
	return(this.canvasArray[this.canvasArray.length-1].testWord(text));
}
//addCanvas();
WordHolder.prototype.addCanvas = function(){
	// Add a canvas
	// we should already know this.nextY so passing it saves us a calculation
	this.canvasArray.push(new SmartCanvas(this.getFont(),this.defaultSize,this.nextY));
}
//setFont() Sets font of latest canvas
WordHolder.prototype.setFont = function(font){
	this.canvasArray[this.canvasArray.length-1].changeFont(font);
}
//getFont() Gets font of latest canvas
WordHolder.prototype.getFont = function(){
	return(this.canvasArray[this.canvasArray.length-1].returnFont());
}
//render() renders all words in word holder
// requires canvas ready for webgl rendering already
// webglcanvas is the webgl canvas words should be rendered to
WordHolder.prototype.render = function(webglcanvas){
}

//	Word is a class that contains each individual text
// It contains:
//		text,
//		canvas where text is,
//		x, x coordinate to be displayed in webgl
//		y, y coordinate to be displayed in webgl
//		xc, x coordinate on the canvas
//		yc, y coordinate on the canvas
//		widthc, width of text on canvas
//		heightc, height of text on canvas
//		verticies, put in webgl buffer
//			quadrilateral verticies
//			texture verticies
function Word(text, canvas, x, y, xc, yc, widthc, heightc){
	this.text = text; // text of the word
	this.canvas = canvas; // which SmartCanvas the word is in
	this.x = x; // x coordinate in webgl
	this.y = y; // y coordinate in webgl
	this.xc = xc; // x coordinate on the canvas
	this.yc = yc; // y coordinate on the canvas
	this.widthc = widthc; // width of text on canvas
	this.heightc = heightc; // height of text on canvas
	this.verticies;
}

// This function renders the word
// requires canvas ready for webgl rendering already
// glcanvas is the webgl canvas to render to
Word.prototype.render = function (glcanvas){
	this.verticies = new Float32Array([
	// Vertex coordinates, texture coordinate
		0.0,  0.0,   0.0, 1.0,
		0.0,  0.0,   0.0, 0.0,
		0.0,  0.0,   1.0, 1.0,
		0.0,  0.4,   1.0, 0.0,
	]);
}


//	Smartcanvas is a canvas with record keeping, contains:
//		canvas,
//		current x coordinate to write a word
//		current y coordinate to write a word
//		next y coordinate to write a word on new line
//		current font
//		texture, stores webgl texture of this canvas
function SmartCanvas(font, size, height){
	// Add new hidden canvas element
	this.canvas = document.createElement("canvas");
	document.body.appendChild(this.canvas);
	this.canvas.height = size; // make sure size works for webgl texture
	this.canvas.width = size;  // ie a square of power of 2
	//this.canvas.setAttribute("style", "visibility:hidden;"); // hide the canvas

	// Font and alignment
	this.font = font;
	var ctx = this.canvas.getContext("2d");
	ctx.textBaseline="top"; //*** CRUCIAL CODE *** makes alignment standard
	ctx.font = font; // set canvas to start with this font

	// Keep track of text locations
	// Start at top left corner and work our way down
	this.lastX = 0;
	this.lastY = 0;
	// If height is defined, we already know height of line
	if(height != undefined){
		this.nextY = height;
	}
	else{ // otherwise calculate it
		this.nextY = this.getFontHeight();
	}

	// Texture for webgl use
	this.texture;
	this.texUpdate = false; // true if we need to retexture on word add
}
//		testWord() see if there is room in canvas
// Return values:
// -1 if need new canvas
// 0 if just write
// 1 if new line needed
SmartCanvas.prototype.testWord = function(text){
	var ctx = this.canvas.getContext("2d");
	//New canvas needed? eg. font size change
	if(this.canvas.height < this.nextY + this.lastY){ // is there room this line?
		return -1; // new canvas
	}

	if((this.canvas.width - this.lastX) < ctx.measureText(text).width){ // new line needed?
		if(this.canvas.height < this.lastY+ this.nextY + this.nextY){ // is there room next line?
			return -1; // new canvas
		}
		else{
			return 1; // new line
		}
	}
	else{ // just write
		return 0;
	}
}
//		writeWord() writes a word to canvas in next available space
// returns canvas coordinates the word is located [x, y]
// To find quadrilateral: width, height, lastX, nextY
SmartCanvas.prototype.writeWord = function(text, testval){
	var ctx = this.canvas.getContext("2d");
	var wordWidth = ctx.measureText(text).width;
	var returnval = [this.lastX, this.lastY];
	// On this line
	if(testval === 0){
		ctx.fillText(text, this.lastX, this.lastY);
		this.lastX += wordWidth;
	}
	// On next line
	else{
		this.lastX = 0;
		this.lastY += this.nextY;
		returnval = [this.lastX, this.lastY]; // update return val
		ctx.fillText(text, this.lastX, this.lastY);
		this.lastX += wordWidth;
	}

	// Let renderer know this canvas has been edited since last texture
	this.texUpdate = true;

	// return [x,y] start location of text
	return returnval;
}
//		changeFont()
SmartCanvas.prototype.changeFont = function(font){
	//console.log("changefont: "+font);
	this.font = font;
	var ctx = this.canvas.getContext("2d");
	ctx.textBaseline="top"; //*** CRUCIAL CODE *** makes alignment standard
	ctx.font = font;

	// Make sure to update nextY if font size is smaller
	var tempHeight = this.getFontHeight();
	if(this.nextY < tempHeight){
		this.nextY = tempHeight;
	}
}
//		returnFont()
SmartCanvas.prototype.returnFont = function(){
	return(this.font);
}
//		getFontHeight() gets height of font when font is changed
// Adapted from this stackoverflow answer by Michaelangelo:
//http://stackoverflow.com/questions/11452022/measure-text-height-on-an-html5-canvas-element
// 1) create div with word and font used in canvas
// 2) measure div
// 3) remove div
SmartCanvas.prototype.getFontHeight = function(){
	//console.log("getfontheight: "+this.font);
	var div = document.createElement("div");
	div.style.position = 'absolute'; // required for making div start out small as possible
	//div.style.left = '-999px';
	//div.style.top = '-999px';
	div.innerHTML = "Hg"; // High and Low word
	//var ctx = this.canvas.getContext("2d");
	var font = "font: "+this.font+";";
	div.setAttribute("style", font);
	document.body.appendChild(div);
	var size = [div.offsetWidth, div.offsetHeight]; // keep this in case width is needed later
	document.body.removeChild(div);
	return size[1];
}

// Global variables
var gl; // webgl program

// Shader programs from code from matsuda and kanda 2012
// Found in WebGL Programming Guide
// Vertex shader program
var VSHADER_SOURCE =
  'attribute vec4 a_Position;\n' +
  'attribute vec2 a_TexCoord;\n' +
  'varying vec2 v_TexCoord;\n' +
  'uniform vec4 u_Translation;\n' +
  'void main() {\n' +
  '  gl_Position = a_Position + u_Translation;\n' +
  '  v_TexCoord = a_TexCoord;\n' +
  '}\n';

// Fragment shader program
var FSHADER_SOURCE =
  '#ifdef GL_ES\n' +
  'precision mediump float;\n' +
  '#endif\n' +
  'uniform sampler2D u_Sampler;\n' +
  'varying vec2 v_TexCoord;\n' +
  'void main() {\n' +
  '  gl_FragColor = texture2D(u_Sampler, v_TexCoord);\n' +
  '}\n';

// Random words
var loremipsum = [
	"Lorem", "ipsum", "dolor", "sit", "amet,", "consectetur", "adipiscing", "elit,", "sed do",
	"eiusmod", "tempor", "incididunt", "ut", "labore", "et", "dolore", "magna", "aliqua.", "Ut enim", "ad", "minim",
	"veniam,", "quis", "nostrud", "exercitation", "ullamco", "laboris", "nisi", "ut", "aliquip", "ex ea", "commodo", "consequat.",
	"Duis", "aute", "irure", "dolor", "in", "reprehenderit", "in", "voluptate", "velit", "esse", "cillum", "dolore", "eu",
	"fugiat", "nulla", "pariatur.", "Excepteur", "sint", "occaecat", "cupidatat", "non", "proident,", "sunt", "in", "culpa", 
	"qui", "officia", "deserunt", "mollit", "anim", "id est", "laborum.",
	"123", "456", "789", "0!@#"
];

function main(){

	// Test WordHolder canvas functionality
	// Test a new WordHolder
	var holder = new WordHolder();
	var initialCanvasWritable = holder.tryAdd();
	// Should testing canvas to add a value should yield 0
	if(initialCanvasWritable===0){
		console.log("Correct. Empty WordHolder Writable val: "+0);
	}
	else if(initialCanvasWritable===1){
		console.log("Incorrect. Empty WordHolder not initially writable val: "+1)
	}
	else{
		console.log("Incorrect. Empty WordHolder not writable val: "+-1)
	}
	
	// Test initial font and getFont function
	var ctx = holder.canvasArray[holder.canvasArray.length-1].canvas.getContext("2d");
	var initialCanvasFont = holder.getFont();
	var initialCtxFont = ctx.font;
	//initialCtxFont = initialCtxFont.replace(/"/g, '');
	if(initialCanvasFont == initialCtxFont){
		console.log("Correct. Initial fonts same.");
	}
	else{
		console.log("Incorrect. Initial fonts not the same.");
		console.log(initialCanvasFont);
		console.log(initialCtxFont);
	}
	
	// Test WordHolder canvas writing
	holder.addWord("Cat",0,0);
	// Confirm visually
	
	// Test WordHolder font change
	holder.setFont('50px "Times New Roman"');
	initialCanvasFont = holder.getFont();
	initialCtxFont = ctx.font;
	//initialCtxFont = initialCtxFont.replace(/"/g, '');
	if(initialCanvasFont == initialCtxFont){
		console.log("Correct. Changed fonts the same.");
	}
	else{
		console.log("Incorrect. Changed fonts not the same.");
		console.log(initialCanvasFont);
		console.log(initialCtxFont);
	}
	holder.addWord("Cat",0,0);
	
	// Test WordHolder canvas packing
	var numtests = 54;
	for(i=0; i<numtests; i++){
		holder.addWord("Magnet",0,0);
	}
	initialCanvasFont = holder.getFont();
	initialCtxFont = ctx.font;
	//initialCtxFont = initialCtxFont.replace(/"/g, '');
	if(initialCanvasFont == initialCtxFont){
		console.log("Correct. New canvas fonts the same");
	}
	else{
		console.log("Incorrect. New canvas fonts not the same.");
			console.log(initialCanvasFont);
			console.log(initialCtxFont);
	}
	
	// Test WordHolder Word functionality
	if(holder.wordArray.length === numtests+2){
		console.log("Correct. Number of words matches number of tests");
	}
	else{
		console.log("Incorrect. Number of words does not match number of tests");
	}
	
	// Visually confirm that words are in boxes
	var testWord;
	for(i=0; i<holder.canvasArray.length; i++){
		ctx = holder.canvasArray[i].canvas.getContext('2d');
		ctx.globalAlpha=0.2;
	}
	for(i=0; i<holder.wordArray.length; i++){
		testWord = holder.wordArray[i];
		ctx = testWord.canvas.canvas.getContext('2d');
		if(i%3 === 0){
			ctx.fillStyle = "red"
		}
		else if(i%3 === 1){
			ctx.fillStyle = 'blue';
		}
		else{
			ctx.fillStyle = 'green';
		}
		ctx.fillRect(testWord.xc, testWord.yc, testWord.widthc, testWord.heightc); // How to find coordinates for texture
	}
	for(i=0; i<holder.canvasArray.length; i++){
		ctx = holder.canvasArray[i].canvas.getContext('2d');
		ctx.globalAlpha=1.0;
	}

	// Test render functions
	// Word and WordHolder render functions assume webgl rendering set up already
	// Retrieve <canvas> element
	var canvas = document.getElementById('webgl');
	// setup event handler
	//canvas.onclick = (function(ev){click(ev,gl,canvas)});
	// setup shader programs 
	setupText(canvas);
	// Specify the color for clearing <canvas>
	gl.clearColor(0, 0, 0, 1);
	// Clear <canvas>
	gl.clear(gl.COLOR_BUFFER_BIT);
	
	// Test Word renderer
	holder.wordArray[3].render(canvas);
	
	
	draw();
	
/*
	// Test SmartCanvas' canvas
	var newcanvas = new SmartCanvas("24px Times New Roman",512);
	console.log(newcanvas.canvas);
	var ctx = newcanvas.canvas.getContext("2d");
	ctx.fillStyle = "red";
	ctx.fillRect(newcanvas.canvas.width/2,newcanvas.canvas.height/2,10,10); // fill in the pixel at (10,10)

	var widthHeight = newcanvas.writeWord("cat",0);
	ctx.globalAlpha=0.2;
	ctx.fillRect(widthHeight[0],widthHeight[1],newcanvas.lastX,newcanvas.nextY); // How to find coordinates for texture
	ctx.globalAlpha=1.0;

	// Test SmartCanvas' font functions
	newcanvas.changeFont("50px Times New Roman");
	console.log(newcanvas.nextY);
	console.log(newcanvas.returnFont());

	// Test SmartCanvas' writing functions
	console.log("Original lastX: " + newcanvas.lastX);
	widthHeight = newcanvas.writeWord("cat",0);
	console.log("lastX after writing: " + newcanvas.lastX);
	console.log(widthHeight);
	ctx.globalAlpha=0.2;
	ctx.fillRect(widthHeight[0],widthHeight[1],newcanvas.lastX-widthHeight[0],newcanvas.nextY); // How to find coordinates for texture
	ctx.globalAlpha=1.0;

	// Test SmartCanvas' packing functions
	var testval = 0;
	var counter = 0;
	do{
		testval = newcanvas.testWord("Magnet");
		if(testval === -1){
			break;
		}
		widthHeight = newcanvas.writeWord("Magnet", testval);
		counter++;
	}while(testval !== -1)
	ctx.globalAlpha=0.2;
	ctx.fillRect(widthHeight[0],widthHeight[1],newcanvas.lastX-widthHeight[0],newcanvas.nextY); // How to find coordinates for texture
	ctx.globalAlpha=1.0;
	console.log("Number of cats: "+counter);
	console.log("Test value: "+testval)
*/

}

function webglToCanvas(x, y, canvas){
	var width = canvas.width;
	var height = canvas.height;
	var newX;
	var newY;

	// Convert to webgl coordinates from canvas
	newX = (x - width/2) / (width/2);
	newY = (height/2 - y) / (height/2);
	console.log(newX+" "+newY);
	return [newX,newY];
}
function canvasToWebgl(x, y, canvas){
	var width = canvas.width;
	var height = canvas.height;
	var newX;
	var newY;

	// Convert to canvas coordinates from webgl
	newX = (x*(width/2)) + width/2;
	newY = ((1-y)*(height/2)); // broken
	console.log(newX+" "+newY);
	return [newX,newY];
}

// Tries to pack a word into a canvas
// Returns true if packed, false if cannot.
function tryPack(lastX,lastY,word,canvas){
	
}

function draw(){

/*
	var canvas = document.getElementById("canvas2");
	var ctx = canvas.getContext("2d");
	ctx.textBaseline="top"; //*** CRUCIAL CODE ***
	ctx.font = "20px Times New Roman";
	ctx.fillStyle = "red";
	//ctx.fillRect(canvas.width/2,canvas.height/2,10,10); // fill in the pixel at (10,10)

	var wordSize = getFontHeight(canvas);
	console.log(wordSize);
	ctx.fillRect(canvas.width/2,canvas.height/2,ctx.measureText("Hg is Mercury").width, wordSize);
	ctx.fillStyle = "blue";
	ctx.fillText("Hg is Mercury", canvas.width/2, canvas.height/2);
	//ctx.fillStyle = "green";
	//var newXY = webglToCanvas(0,0, canvas);
	//var newXY = webglToCanvas(canvas.width-10,0, canvas);
	//var newNewXY = canvasToWebgl(newXY[0], newXY[1], canvas);
	//ctx.fillRect(newNewXY[0],newNewXY[1],10,10); // fill in the pixel at (10,10)
*/
}
function animate(){
	
}

// Adapted from this stackoverflow answer by Michaelangelo:
//http://stackoverflow.com/questions/11452022/measure-text-height-on-an-html5-canvas-element
// 1) create div with word and font used in canvas
// 2) measure div
// 3) remove div
function getFontHeight(canvas){
	var div = document.createElement("div");
	div.style.position = 'absolute'; // required for making div start out small as possible
	//div.style.left = '-999px';
	//div.style.top = '-999px';
	div.innerHTML = "Hg"; // High and Low word
	var ctx = canvas.getContext("2d");
	var font = "font: "+ctx.font+";";
	div.setAttribute("style", font);
	document.body.appendChild(div);
	var size = [div.offsetWidth, div.offsetHeight];
	document.body.removeChild(div);
	return size[1];
}

function click(ev, gl, canvas) {
  var x = ev.clientX; // x coordinate of a mouse pointer
  var y = ev.clientY; // y coordinate of a mouse pointer
  var rect = ev.target.getBoundingClientRect() ;
  
  // Reduce error from bounding box
  x = x-rect.left;
  y = y-rect.top;
  
  // Figure out what length is good (for leg of square quadrilateral)
  var toX = x+length;
  var toY = y+length;
  

  
  x = (x - canvas.width/2)/(canvas.width/2);
  y = (canvas.height/2 - y)/(canvas.height/2);
  
  toX = ((toX) - canvas.width/2)/(canvas.width/2);
  toY = (canvas.height/2 - (toY))/(canvas.height/2);
  
}

// Call this function to ready text rendering
function setupText(canvas){
  // Get a WebGL context inspired from example on MDN:
  // https://developer.mozilla.org/en-US/docs/Web/WebGL/Getting_started_with_WebGL
  gl = null;
  gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
    // Make sure we got a context
  if (!gl) {
    alert("Failed to initialize WebGL. Please use a WebGL compatible browser.");
    gl = null;
    return;
  }

  // IMPORTANT
  // This code allows WebGL to do transparencies
  // Without these lines, a white box will show up
  // from: http://webglfundamentals.org/webgl/lessons/webgl-text-texture.html
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  
  // Initialize shaders
   if (!initializeShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) {
    console.log('Failed to intialize shaders.');
    return;
  }
}

// This function initializes shaders
// modified from cuon-utils.js from WebGL Programming Guide
// Returns true if shaders successfully initialized in program
// Returns false otherwise
function initializeShaders(gl, vshader, fshader){
	// make and verify vertex shader object
	var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	if(vertexShader == null){
		console.log("Unable to create vertex shader");
		return false;
	}
	
	// set vertex shader program source and compile
	gl.shaderSource(vertexShader, vshader);
	gl.compileShader(vertexShader);
	
	// Check result of vertexShader compilation
	if(!(gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS))){
		var errorMsg = gl.getShaderInfoLog(vertexShader);
		console.log('Failed to compile vertex shader: ' + errorMsg);
		gl.deleteShader(vertexShader);
		return false;
	}
	
	
	// make and verify fragment shader object
	var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	if(fragmentShader == null){
		console.log("Unable to create fragment shader");
		return false;
	}
	
	// set fragment shader program source and compile
	gl.shaderSource(fragmentShader, fshader);
	gl.compileShader(fragmentShader);
	
	// Check result of fragmentShader compilation
	if(!(gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS))){
		var errorMsg = gl.getShaderInfoLog(fragmentShader);
		console.log('Failed to compile fragment shader: ' + errorMsg);
		gl.deleteShader(fragmentShader);
		return false;
	}

	// Verify both shaders created
	if(!vertexShader || !fragmentShader){
		console.log("shaders no load");
		return false;
	}

	// make and verify program object
	var program = gl.createProgram();
	if(!program){
		console.log("program no create");
		return false;
	}

	// Attach vertex and fragment shader to program object
	gl.attachShader(program, vertexShader);
	gl.attachShader(program, fragmentShader);

	// Link program and verify linkng
	gl.linkProgram(program);
	if(!(gl.getProgramParameter(program, gl.LINK_STATUS))){
		var errorMsg = gl.getProgramInfoLog(program);
		console.log('Program filed to link: ' + errorMsg);
		gl.deleteProgram(program);
		gl.deleteShader(fragmentShader);
		gl.deleteShader(vertexShader);
		console.log("no program got");
		return false;
	}

	// Use and set the program
	gl.useProgram(program);
	gl.program = program;
	return true;
}
</script>

  </body>
</html>
